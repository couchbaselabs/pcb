## Framing

The server may send responses out of order w.r.t. to requests.

    Message := Header Body;
    
    Header := Type RestOfHeader;
    
    Type := byte {
        REQUEST = 1,
        RESPONSE = 2,
        STREAM_BEGIN = 3,
        STREAM_MESSAGE = 4,
        STREAM_CLOSE = 5,
        REQUEST_ERRONLY = 6
    };
    
    RestOfHeader := byte[48];
    // Interpretation of RestOfHeader depends on the Type.
    
    Body := byte[];
    // Body bytes are protobuf encoded and may be 0 length (empty).
    
    BodyLen := uint32;
    
    RqId := uint16;
    // A unique request number generated by the client.
    
    StreamId := uint16;
    
    pad16 := byte[16]; // 16 bytes of padding, all zero.
    pad32 := byte[32]; // 32 bytes of padding, all zero.

### Message Types

    REQUEST := RqID BodyLen;
        // A request always is paired with a single response.
    
    RESPONSE := RqID BodyLen;

    STREAM_BEGIN := StreamID RqId pad16;
        // Servers MUST send their STREAM_BEGIN messages before the
        // associated RESPONSE is sent.
        // Streams are explicit in the framing layer so that a
        // relay / proxy layer can pair streams to clients.
    
    STREAM_MESSAGE := StreamID BodyLen;
    
    STREAM_CLOSE := StreamID pad32;
    
    REQUEST_ERRONLY := RqID BodyLen;
        // Only response to a REQUEST_ERRONLY will be an error.

### TODO

Perhaps require that RqID is smaller than
some size so proxies can do non-tabling
client-request pairing for these, since
they may not have responses and can't
be cleaned out.

### How should a proxy handle REQUEST_ERRONLY?
